# -*- coding: UTF-8 -*-
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.action_chains import ActionChains
import prettytable as pt
import time,os,re,codecs,shutil,hashlib
# 使用到一些第三方库。如果提示缺少xxx，请执行在控制台执行 pip install xxx

#===============================================================================
# * 声明
#===============================================================================
# 作者：XHXIAIEIN
# 更新：2020/11/03
# 主页：https://github.com/XHXIAIEIN/Auto-Download-QQEmail-File
#===============================================================================

#===============================================================================
# * 如何安装
#===============================================================================

#...............................................................................
#  1.WebDriver for Chrome
#...............................................................................
#  使用前检查Chrome与chromedriver版本是否一致，若Chrome有更新，请更新chromedriver
#  https://sites.google.com/a/chromium.org/chromedriver/downloads
#...............................................................................

#...............................................................................
#  2.需要安装几个必要的工具库。
#...............................................................................
#  Windows用户，安装NodeJs后，在cmd输入以下指令：
#  python -m pip install --upgrade pip
#  pip install selenium
#  pip install prettytable
#...............................................................................
#  MAC用户，安装brew后，在终端输入以下指令：
#  brew install chromedriver
#  brew install selenium
#  brew install prettytable
#...............................................................................

'''
#===============================================================================
#  自定义参数
#===============================================================================
'''

# 是否为MacOS用户。
is_mac_user = False

#...............................................................................
#  QQ账号 （放心填，没人能看到）
#...............................................................................

QQNUMBER="132465798"
PASSWORD="132465798"

#...............................................................................
#  邮箱文件夹ID
#...............................................................................
#  展开左侧面板[我的文件夹]列表，找到你想下载的文件夹，右键-新窗口打开。
#  在浏览器地址栏找到folderid 
#  mail.qq.com/cgi-bin/frame_html?t=frame_html&sid=x&url=/cgi-bin/mail_list?folderid={ A }%26page=0
#...............................................................................

FOLDER_ID = 123

#...............................................................................
# 附件下载到哪个文件夹。
#...............................................................................
# 
# 若文件夹不存在，会自动创建。但仅处理1层路径。
#
# 注1：如需在当前脚本所在的路径创建目录，直接写名称，如："QQMail"
#
# 注2：Win用户文件夹路径用 '\\' 作为分隔符。如："d:\\email\\download\\"
#      Mac用户用 '/' 分隔。如："~/Downloads/2020/"
#
# 注3：文件夹路径必须以分隔符结尾。
#...............................................................................

DOWNLOAD_FOLDER='D:\\Downloads\\'


#...............................................................................
# 配置 Web Driver
#...............................................................................

options = webdriver.ChromeOptions()
prefs={"download.default_directory":DOWNLOAD_FOLDER}
options.add_experimental_option("prefs",prefs)
options.add_argument("--window-size=900,1000")
options.add_argument("--user-agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36 Edg/80.0.361.66'")
options.add_argument("--blink-settings=imagesEnabled=false")  # 禁止网页显示图片

try: 
  if not is_mac_user:
    options.add_argument("--user-data-dir=selenium")
    chrome = webdriver.Chrome(options=options);
  else:
    options.add_argument("--user-data-dir selenium");
    chrome = webdriver.Chrome('/usr/local/bin/chromedriver', options=options)
except: 
  print('无法打开浏览器。检查是否已运行了另一个脚本。'); 
  os.system("PAUSE");

#...............................................................................
#  若自动登陆失败，可尝试手动登录。
#...............................................................................
#  
#  为什么会失败？ 
#  登陆时出现了验证码滑块以及手机验证。但浏览器已经禁止显示图片。
#  
#  解决方案1：
#  临时注释掉上方的 “[禁止网页显示图片]” 声明。
#  options.add_argument("--blink-settings=imagesEnabled=false")
#  禁用后，再次启动脚本，手动登陆并勾选记住密码，下次自动登陆。
#  登陆成功后，下次运行脚本就可以直接进入邮箱主页了。
#  如果尝试1次不成功，可以多登陆几次。
# 
#  解决方案2：
#  可以使用SID手动登录。
#  手动登陆后，从浏览器地址栏中找到这个参数: sid 
#  mail.qq.com/cgi-bin/frame_html?sid={ xxxxxx }&r={ 这个可以无视 }
#  这串随机字符偶尔也会以符号作为结尾，复制的时候需要注意。
#
#
#  解决方案3：
#  可以利用Cookies登陆。
#  如果你某个浏览器已经可以不需要填写密码自动登陆。
#  按下F12，打开 DevTools 窗口。上面切换到 Application 标签，左边找到 Cookies 
#  展开，打开第一个 https://mail.qq.com，找到 pcache 字段
#  复制 pcache 以及它后面的值。以相同的方式复制到另一个浏览器就可以自动登陆了。
#  步骤1：添加 Cookies 的方式是双击空白处，即可添加新字段，填入 pcache
#  步骤2：将它的值粘贴进入。
#  步骤3：刷新页面，就自动进入主页了。
#...............................................................................
URLTEMP_SID = ""


#...............................................................................
#  如果懒得找文件夹ID，也可以用索引序号[替换]文件夹ID。
#  若不使用索引编号，请设置为 -1
#  注：置顶的文件夹不在此列表中
#...............................................................................
FOLDER_INDEX = -1   # 首页收件箱的索引序号是0

#...............................................................................
#  重命名规则(未完成) 请手动搜索 can_rename_file 修改
#...............................................................................
# file_name1         附件原始的文件名(包含扩展名）例如: 简历.pdf
# file_name2         附件原始的文件名(不包含扩展名）例如: 简历
#...............................................................................
# extension1         附件原始的扩展名(包含.) 例如:.jpg .txt .pdf
# extension2         附件原始的扩展名(不包含.) 例如: jpg  txt  pdf
#...............................................................................
# file_count_index  该文件在本次下载程序中的顺序，即下载的第几个文件。
# file_title_index  该文件在本邮件中附件顺序。(从0开始计数)
#...............................................................................
# sender_nameid     
# sender_emailid    发信方的邮箱ID，如果使用的是QQ邮箱，即为去除@qq.com的结果。
# sender_address    发信方的邮箱地址。例如：123456@qq.com
#...............................................................................
# title_count_index 本篇邮件在本次下载程序中的顺序。
#...............................................................................
# title_send_date  发送时间。例：10月30日 => 1030
# title_send_month 发送日期。例：10月30日 => 10
# title_send_day   发送日期。例：10月30日 => 30
#...............................................................................
# title_send_week     发送时间。例：星期二 => 星期二
# title_send_time     发送时间。例：下午4 : 29 => 1629
# title_send_hours    发送时间。例：下午4 : 29 => 16
# title_send_minutes  发送时间。例：下午4 : 29 => 29
#...............................................................................

file_rename_rules = ''


#...............................................................................
#  高级选项
#...............................................................................

# 等待页面加载元素时长。
# 减小数值可加快处理速度，但更容易翻车。你也可以尝试0.1，真的很快乐。
implicitly_wait_time = 0.1

# 是否根据投稿时间顺序下载附件。即：从最后一页往前下载。
can_reverse_list = False

# 是否按投稿邮箱创建文件夹
can_move_folder = False

# 下载后是否重命名文件
can_rename_file = True

# 是否自动设置【每页显示100封邮件】以及【邮件列表视图为标准模式】
can_setting_mail = False

# 是否只登陆到邮箱主页，不做任何事
just_login_mail = False

# 是否只打印主题列表，不打开邮件
just_print_mail = False

# 是否只打印附件列表，不下载附件
just_print_file = False

#是否将不含附件的主题设置为星标
is_star_nofile = True

#是否将不含附件的主题，导出eml文件
is_dleml_nofile = False

#是否在控制台输出数据
can_print_folder_table = True
can_print_title_table = True
can_print_files_table = True

#下载结束后跳转到首页
is_ended_jump_home = True

#生成邮件列表csv文件
is_export_titlelist_csv = True

#生成附件列表csv文件
is_export_filelist_csv = True

#...............................................................................
# 指定下载计划。
#...............................................................................
#  start: 从列表第n个开始。（包含n，即列表第一个就是n。）默认值：1
#  end:   在列表第n个结束。（包含n，即列表最后一个是n。）默认值：-1
#  step:  从开始计算，累计n个结束。（即列表最终有n个。若index大于end或max，提前结束step。）默认值：-1
#...............................................................................

# 邮件列表
Title_Task = { 'start':1, 'step':-1, 'end':-1 }

# 翻页规则
Pages_Task = { 'start':1, 'step':-1, 'end':-1, 'autoNext': True }


#...............................................................................
# 邮件主题，关键词过滤
#...............................................................................

# 白名单关键词。只搜索邮件主题中包含任意一个关键词的邮件。
# 示例：title_whitelist_keys = ['反馈','回复']
title_whitelist_keys = ['']

# 黑名单关键词。忽略邮件主题中包含任意一个关键词的邮件。
# 示例：title_blacklist_keys = ['发信方已撤回邮件','QQ会员业务通知邮件']
title_blacklist_keys = ['发信方已撤回邮件']


# 文件 扩展名黑名单
# 示例：r'(txt)|(psd)|(ai)|(docx)|(pdf)|(psb)|(cdr)|(sketch)'
file_extension_blacklist = r'(exe)|(vb)'


'''
#===============================================================================
#                  "请 勿 跨 过 这 块 区 域 修 改 内 容"
#===============================================================================
'''

#...............................................................................
# GLOBAL VAR
#...............................................................................

count_download_email = {"count":0, "lastMailID": ""}
config = {}
config['PTASK'] = ''
config['TTASK'] = ''
config['TOKEN'] = {'sid':"",  'folderid':0, 'page':0}
config['PAGES'] = {'index':0, 'max': 0, 'step':0, 'iscanNext':False, 'isNotFistPage':0}
config['TITLE'] = {'index':0, 'max': 0, 'step':0, 'isFileDownload': False}

split_sign = os.sep

#...............................................................................
# Data
#...............................................................................

data_folders_list = []
data_folders_dict = []
data_title_blacklist = []
data_title_whitelist = []
data_email_titlelist = []
data_email_fileslist = []
data_email_nofilelist = []

#...............................................................................
# Table
#...............................................................................

table_title_whitelist = pt.PrettyTable()
table_title_whitelist.field_names = ["序","发件人","没有包含白名单关键词的主题","邮箱","时间","页"]
table_title_whitelist.align = "l"

table_title_blacklist = pt.PrettyTable()
table_title_blacklist.field_names = ["序","发件人","包含了黑名单关键词的主题","邮箱","时间","页"]
table_title_blacklist.align = "l"

table_email_titlelist = pt.PrettyTable()
table_email_titlelist.field_names = ["序","发件人","主题","邮箱","时间","页"]
table_email_titlelist.align = "l"

table_email_nofilelist = pt.PrettyTable()
table_email_nofilelist.field_names = ["序","发件人","没有附件的主题","邮箱","时间","页"]
table_email_nofilelist.align = "l"

table_email_fileslist = pt.PrettyTable()
table_email_fileslist.field_names = ["序","页","发件人","文件名","主题","邮箱","大小","类型","时间","附序"]
table_email_fileslist.align = "l"

#...............................................................................
# Utility
#...............................................................................

def p1(text):
    try:print(text)
    except: print("控制台打印了一些内容，但因为字符中含有某些特殊符号，无法显示。")

# 打开链接
def get_url(url):
    chrome.get(url)
    chrome.implicitly_wait(implicitly_wait_time)

# 检查SID是否存在，若存在则跳过自动填写账号密码登陆
def test_sid_exists():
  return bool(URLTEMP_SID)

# 检查页面元素是否存在
def test_id_exists(name):
    try: return chrome.find_element_by_id(name) != 'null'
    except: return False

# 检查class元素是否存在。如果指定了min，则检查class元素的数量。
def test_class_exists(name, min=0):
    try: return len(chrome.find_elements_by_class_name(name)) > min
    except: pass; #print("无法获取class元素: {} \n".format(name))

# 检查页面元素ID是否存在。如果存在则返回元素
def test_id_exists_get(name):
    try: e=chrome.find_element_by_id(name); chrome.execute_script("window.stop()"); return e
    except:return False

# 检查页面元素Class是否存在。如果存在则返回元素
def test_class_exists_get(name):
    try:e=chrome.find_elements_by_class_name(name); chrome.execute_script("window.stop()"); return e
    except:return False

# 检查iframe框架是否存在，如果存在将焦点跳转到该iframe
def test_frame_exists(name):
    try: e=test_id_exists_get(name); chrome.switch_to.frame(e); return e
    except:return False

# 检查列表是否为空
def test_list_exists(i):
    return bool(i) and i != ['']

# 如果字符串中含有某个关键词，返回True
def check_key_in_name(str, key):
    return all([i in str for i in key])

# 时间戳转换时间
def timeStamp(t):
    return time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(float(t/1000)))

# 反转字典, value to key
def swapDict(d):
    result = {}
    for k, v in d.items():
        for _k in v:
          result.setdefault(_k, {})
          result[_k][k] = d[k][_k]
    return result

# 将Table导出为csv文件
def ptable_to_csv(table, filename):
    raw = table.get_string()
    data = [tuple(filter(None, map(str.strip, splitline)))
    for line in raw.splitlines()
    for splitline in [line.split('|')] if len(splitline) > 1]
    with codecs.open(filename,'w','utf_8_sig') as f: 
      for d in data: f.write('{}\n'.format(','.join(d)))

# 反向顺序下载
class list_reverse:
  def __init__(self,it):
      self.it = iter(it)
      self.buf = []
  def __iter__(self): 
    return self
  def __next__(self):
      if self.buf:
          return self.buf.pop()
      return next(self.it)
  def push(self,item): 
    self.buf.append(item)

#...............................................................................
#  CHECK FILES DOWNLOAD
#...............................................................................

# 检查文件夹路径是否存在(仅检查1层)
def check_download_exists(path = DOWNLOAD_FOLDER):
    if not os.path.exists(path):
      print_folder_exists();
      os.mkdir(path)

# 检测文件是否已经存在
def check_file_exists(filename, filepath = DOWNLOAD_FOLDER):
    if filename == '.DS_Store' or filename == 'thumbs.db' : return False
    return os.path.isfile(os.path.join(filepath, filename))

# 返回最后一个下载完成的文件路径
def get_last_filepath():
    files = list(filter(check_file_exists, os.listdir(DOWNLOAD_FOLDER)))
    if len(files) == 0:
      return ''
    else:
      files.sort(key=lambda fn: os.path.getmtime(DOWNLOAD_FOLDER + os.sep + fn))
      return os.path.join(DOWNLOAD_FOLDER, files[-1])

# 返回文件的md5
def check_md5(filepath):
  with open(filepath, "rb") as f: 
    return hashlib.md5(f.read()).hexdigest()

# 检查文件在文件夹中是否重复,若重复则删除。只保留最原始的一份.
def remove_repeat_file(onlyname, copyfilepath, path = DOWNLOAD_FOLDER):
  filelist = (file for file in os.listdir(path) if os.path.isfile(os.path.join(path, file)))
  for f in filelist:
    if check_md5(copyfilepath) == check_md5(f) and os.path.basename(copyfilepath) != onlyname: print(f'重复文件 {copyfilepath}'); os.remove(copyfilepath) 


#...............................................................................
#  LOGIN
#...............................................................................

# 更新token
def update_token():
    token = config['TOKEN']
    token["sid"]      =  URLTEMP_SID if bool(URLTEMP_SID) else chrome.current_url.split("sid=")[1].split("&")[0]
    token["folderid"] =  data_folders_list[FOLDER_INDEX]["id"] if FOLDER_INDEX > 0 else 0 if FOLDER_INDEX == 0 else FOLDER_ID if FOLDER_ID > 0 else 0
    token["page"]     =  0

# 自动登录
def auto_login():
    p1("尝试自动登录")
    chrome.switch_to.default_content()
    test_frame_exists("login_frame")
    if test_class_exists('face', 1): test_id_exists("switcher_plogin").click()
    test_id_exists("u").clear()
    test_id_exists("u").send_keys(QQNUMBER)
    test_id_exists("p").clear()
    test_id_exists("p").send_keys(PASSWORD)
    test_id_exists("p_low_login_enable").click()
    test_id_exists("login_button").click()
    if test_id_exists("mainFrameContainer"): p1("登录成功")

    time.sleep(2)

    if test_id_exists("tcaptcha_iframe"):
      trigger_once = True
      while bool(test_id_exists("tcaptcha_iframe")):
        if trigger_once: print("等待用户手动完成拼图认证..."); trigger_once = False;
        time.sleep(3)

    if test_id_exists("login_frame"):
      trigger_once = True
      while bool(test_id_exists("login_frame")):
        if trigger_once: print("等待用户完成登陆验证..."); trigger_once = False;
        time.sleep(3)

    if test_id_exists("mainFrame"): 
      update_token()
      print("登陆完成！")


# 修改邮箱每页显示数量100
def setting_email():
  p1("修改邮箱设置：[邮件列表每页显示数量]和[邮件列表视图]")
  get_url("https://mail.qq.com/cgi-bin/frame_html?t=frame_html&sid={}&url=/cgi-bin/setting1?fun=list".format(config['TOKEN']["sid"]))
  test_frame_exists("mainFrame")
  # 修改邮箱每页显示数量100
  e = test_class_exists_get("btn_select_limiting")[1]
  e.click()
  e.send_keys(Keys.DOWN); time.sleep(0.1)
  e.send_keys(Keys.DOWN); time.sleep(0.1)
  e.send_keys(Keys.ENTER); time.sleep(0.2)
  # 修改邮箱邮件列表视图为标准模式，而不是会话模式
  test_frame_exists("mainFrame");
  ActionChains(chrome).click(test_id_exists_get("listmode1")).perform()
  # 保存
  test_frame_exists("mainFrame");
  chrome.execute_script("document.getElementById('sendbtn').click();") # 舒服了。。乖乖得写总是点不了保存按钮。


#...............................................................................
#  GET FOLDER LIST
#...............................................................................

# 获取文件夹列表
def get_folder_list():
  if not test_id_exists("leftPanel") and not test_id_exists("folders"): error_load_folder()
  n,d=0,[]
  elements = iter(chrome.find_element_by_id("personalfolders").find_elements_by_tag_name("li"))
  for item in elements:
      n += 1
      a = item.find_elements_by_tag_name("a")[0]
      aid = a.get_attribute('id').split('_')[1]
      atl = a.get_attribute('title')
      data_folders_list.append({'index':n, 'id': int(aid), 'name': atl})
      d.append([aid,atl])
  global data_folders_dict
  data_folders_dict = dict(d)
  print_folder_table()

#...............................................................................
# GET EMAIL LIST
#...............................................................................

# 进入文件夹
def open_next_page():
    token = config['TOKEN']
    get_url("https://mail.qq.com/cgi-bin/mail_list?folderid={}&page={}&sid={}&nocheckframe=true".format(token['folderid'],token['page'],token['sid']))
    get_folder_info()
    get_email_title()

# 获取文件夹页数信息
def get_folder_info():
    test_frame_exists("mainFrame")
    token = config['TOKEN']
    token['page'] += 1
    config["PAGES"]["step"] += 1
    config["PAGES"]["isNotFistPage"] = 1 if token['page'] != 1 else 0
    config["PAGES"]["iscanNext"] = test_id_exists("nextpage")
    config["PAGES"]["index"] = token['page']
    config["PAGES"]["max"] = eval(test_class_exists_get("right")[1].find_elements_by_tag_name("script")[0+config["PAGES"]["isNotFistPage"]].get_attribute('innerHTML').strip('document.write(').strip(');'))
    if token['page'] > Pages_Task["start"] > 0: return
    os.system("cls")


# 获取文件夹的邮件列表
def get_email_title():
    data1,data2=[],[]
    # 基础信息
    elements=iter(chrome.find_elements_by_css_selector('input[name="mailid"]'))
    for index,e in enumerate(elements):
      if index < 1: continue
      config["TITLE"]["max"] += 1
      mail={}
      mail.update({"page":"{}".format(config["PAGES"]["step"])})
      mail.update({"index":"{:03d}".format(config["TITLE"]["max"])})
      mail.update({"email":e.get_attribute("fa")})
      mail.update({"name":e.get_attribute("fn")})
      mail.update({'timestamp':e.get_attribute("totime")})
      mail.update({"mailid":e.get_attribute("value")})
      data1.append(mail)

    # 邮件标题
    elements = iter(test_class_exists_get("tt"))
    for e in elements: data2.append({"title": e.get_attribute('innerHTML').replace('&nbsp;','')})

    # 合并两个list
    # 在这里处理白名单、黑名单。以及 TASK TITLE
    for a,b in zip(data1, data2):
        a.update(b)
        if test_list_exists(title_blacklist_keys) and check_key_in_name(a['title'],title_blacklist_keys): data_title_blacklist.append(a)
        elif test_list_exists(title_whitelist_keys) and not check_key_in_name(a['title'],title_whitelist_keys): data_title_whitelist.append(a)
        else:
          if int(a['index']) > Title_Task["end"] > 0:break
          if config["TITLE"]["step"] >= Title_Task["step"] > 0:break
          if Title_Task["start"] > int(a['index']) > 0 : continue
          config["TITLE"]["step"]+=1
          data_email_titlelist.append(a)

    # 检查翻页
    open_next_page() if check_page_can_next() else check_task_end_type()

#...............................................................................
# NEXT PAGE
#...............................................................................

#检查是否需要翻页
def check_page_can_next():
    if not Pages_Task['autoNext'] or not config["PAGES"]["iscanNext"]: return False
    if config['TOKEN']['page'] > Pages_Task["end"] > 0: config['PTASK']='e';return False
    if config["PAGES"]["step"] > Pages_Task["step"] > 0: config['PTASK']='s';return False
    if config['TITLE']['index'] > Title_Task["end"] > 0: config['TTASK']='e';return False
    if config['TITLE']['step'] >= Title_Task["step"] > 0: config['TTASK']='s';return False
    return True

#检查时以哪种方式结束翻页的
def check_task_end_type():
  p,t = config['PTASK'],config['TTASK']
  tp,tt,cp,cd = Pages_Task,Title_Task,config["PAGES"],config["TITLE"]
  if not tp['autoNext'] and (tp["step"] > 0 or tt["step"] > 0 or tp["end"] > 0 or tt["end"]) > 0: stop_by_page_next()
  tp["start"] = tp["start"] if tp["start"] > 0 else 1
  tt["start"] = tt["start"] if tt["start"] > 0 else 1
  tp["end"] = tp["end"] if tp["end"] > 0 else cp["max"]
  tt["end"] = tt["end"] if tt["end"] > 0 else len(data_email_titlelist)
  tp["step"] = tp["step"] if tp["step"] > 0 else cp["step"]
  tt["step"] = tt["step"] if tt["step"] > 0 else cd["step"]
  stop_by_page_end() if p == 'e' else stop_by_page_step()
  stop_by_title_end() if t == 'e' else stop_by_title_step()
  if can_print_title_table : print_title_table()

#...............................................................................
#  GET EMAIL FILES
#...............................................................................

# 打开邮件
def open_email():

    titlelist = list_reverse(data_email_titlelist)

    max = len(data_email_titlelist)
    check_download_exists(DOWNLOAD_FOLDER)  #检查下载路径是否存在

    while True:
      if count_download_email["count"] >= max: download_end(); break
      email = next(titlelist)

      emailpath = DOWNLOAD_FOLDER

      # 创建文件夹，以发信人邮箱命名
      if can_move_folder:
        emailpath = DOWNLOAD_FOLDER + split_sign + email['email'] + split_sign
        if not os.path.exists(emailpath): os.mkdir(emailpath)

      try:
        test_frame_exists("mainFrame")
        check_frame_timeout(email['index']) # 您请求的频率太快，请稍后再试

        chrome.get("https://mail.qq.com/cgi-bin/frame_html?t=newwin_frame&sid={}&url=/cgi-bin/readmail?t=readmail%26mailid={}%26mode=pre".format(config['TOKEN']["sid"],email['mailid']))
        chrome.implicitly_wait(1)

        time.sleep(0.08)
        test_frame_exists("mainFrame")
        check_frame_timeout(email['index']) # 您请求的频率太快，请稍后再试

        #附件列表
        elements1=test_class_exists_get("ico_big")

        if len(elements1) <= 0:
          p1("{} 没有邮件".format(email['index']))
          data_email_nofilelist.append(email)

          #下载eml文件
          if is_dleml_nofile:
            ActionChains(chrome).click(test_id_exists_get("aSwitchOption")).perform()
            ActionChains(chrome).click(test_id_exists_get("trOption").find_elements_by_tag_name("a")[2]).perform()

          #设置为星标
          if is_star_nofile:
            mark_star=test_id_exists_get("img_star");
            if test_class_exists('qm_ico_flagoff'): mark_star.send_keys(Keys.SPACE);

          continue;

        #下载按钮
        elements2=test_class_exists_get("down_big")

        if len(elements2) <= 0:
          p1("{} 没有下载按钮，可能已过期".format(email['index']))

          #下载eml文件
          if is_dleml_nofile:
            ActionChains(chrome).click(test_id_exists_get("aSwitchOption")).perform()
            ActionChains(chrome).click(test_id_exists_get("trOption").find_elements_by_tag_name("a")[2]).perform()

          #设置为星标
          if is_star_nofile:
            mark_star=test_id_exists_get("img_star");
            if test_class_exists('qm_ico_flagoff'): mark_star.send_keys(Keys.SPACE);

          continue;

        #整理附件信息，并下载附件
        for f in elements1:
          a = f.find_elements_by_tag_name('a')[0]
          attach={}
          attach.update({'filename': a.get_attribute('filename')})
          attach.update({'filebyte': int(a.get_attribute('filebyte'))})
          attach.update({'filedown': "https5://mail.qq.com" + a.get_attribute('down')})
          attach.update({'viewmode': a.get_attribute('viewmode')})
          attach.update({'index': int(a.get_attribute('idx') or 0)})
          attach.update({'ti': email['index']})
          attach.update({'tn': email['name']})
          attach.update({'tt': email['title']})
          attach.update({'page': email['page']})
          attach.update({'email': email['email']})
          attach.update({'timestamp': email['timestamp']})
          data_email_fileslist.append(attach)

          # 过滤文件名
          file_extension = attach['filename'].split(".")[-1].lower()
          if re.findall(file_extension_blacklist, file_extension): print("{} 跳过 {} ".format(email['index'], file_extension)); continue;
          p1("{} {}".format(email['index'],attach['filename'],email['email']))

          if just_print_file: continue

          # 点击下载按钮
          downlnk = elements2[attach['index']].find_elements_by_link_text('下载')[0]
          ActionChains(chrome).click(downlnk).perform()

          # 等待下载
          while True:
            filepath = get_last_filepath()
            filename = os.path.basename(filepath)
            filesize = os.path.getsize(filepath)
            filetype = filepath.split('.')[-1]

            rootpath = os.path.split(filepath)[0] + split_sign

            if filepath != '' and filetype != 'crdownload' and filetype != 'tmp' and filesize == attach['filebyte']:

                # 文件重命名规则
                rule = { 
                  'file_name1': attach['filename'], 
                  'file_name2': attach['filename'].split(".")[0], 
                  'extension1': attach['filename'].split(".")[1], 
                  'extension2': attach['filename'].split(".")[-1], 
                  'file_count_index': count_download_email["count"],
                  'file_title_index': attach['index'], 
                  'title_count_index': email['index'],
                  'sender_nameid': email['name'],
                  'sender_emailid': email['email'].split("@")[0],
                  'sender_address': email['email'],
                  'timestamp': email['timestamp'],
                }

                # 检测文件是否已存在
                if check_file_exists(filename, emailpath):

                  # 检测文件MD5是否相同
                  if check_md5(filepath) == check_md5(os.path.join(emailpath, filename)) and filename != attach['filename']: 
                    os.remove(filepath); break;

                  # 是否需要移动到文件夹
                  if can_move_folder: shutil.move(filepath, emailpath); break;
                
                if can_rename_file: 
                  os.rename(filepath, rootpath + email['email'] + '_' + filename); break;

                break
            else:
              time.sleep(1)

        p1("")
        count_download_email["count"] += 1
      except Exception as e:
          p1(e)
          titlelist.push(email)
          chrome.refresh();

# 检测“您请求的频率太快，请稍后再试”
def check_frame_timeout(index):

  pause = test_class_exists("errorIcon") or test_id_exists("msg_txt") or not test_id_exists("contentDiv")

  if pause:
    p1("\n{} 正在队列中等待...请稍等".format(index))
    wait = 0
    while test_id_exists("msg_txt") or test_class_exists("errorIcon"):
      if wait == 0: time.sleep(0.5)
      elif wait == 1: time.sleep(2)
      elif wait == 2: time.sleep(3)
      elif wait == 3: time.sleep(4);chrome.refresh()
      elif wait%4 == 0: time.sleep(2);chrome.refresh()
      else:time.sleep(1)
      wait+=1
    test_frame_exists("mainFrame")
    pause = False
    p1("{} 等待结束，任务继续。\n".format(index))


#...............................................................................
# Print Console Log
#...............................................................................

def error_qlogin(): p1("登录失败。请尝试登录QQ客户端后重试")
def error_load_page(): p1("打开文件夹失败。")
def error_load_title(): p1("获取邮件列表失败。")
def error_load_folder(): p1("获取文件夹列表失败。")
def error_seting_email(): p1("设置失败。")

def stop_by_title_step(): p1("[TITLE STEP]从第{}封邮件开始，读取{}封邮件后结束。".format(Title_Task['start'],Title_Task['step']))
def stop_by_page_step(): p1("[PAGES STEP]从第{}页开始，读取{}页后结束。".format(Pages_Task['start'],Pages_Task['step']))
def stop_by_page_next(): p1("[PAGES NEXT]由于关闭了自动翻页，提前结束。")
def stop_by_page_end(): p1("[Task PAGE]从第{}页开始，在第{}页结束。".format(Pages_Task['start'],Pages_Task['end']))
def stop_by_title_end(): p1("[Task TITLE]从第{}封邮件开始，在第{}封邮件结束。".format(Title_Task['start'],Title_Task['end']))

def print_folder_exists(): p1("文件夹不存在。正在自动创建文件夹....")
def print_download_end(): p1("结束了。{}/{}".format(count_download_email["count"], len(data_email_titlelist)))

#...............................................................................
# Print TABLE
#...............................................................................

# 打印文件夹表格
def print_folder_table():
    if not can_print_folder_table: return
    tb0 = pt.PrettyTable()
    tb0.field_names = ["序", "id", "文件夹"]
    tb0.align = "l"
    tb0.reversesort=True
    for a in data_folders_list: tb0.add_row(["%02d"%a['index'], a['id'], a['name']])
    p1(tb0)

# 打印邮件标题表格
def print_title_table():
    # 黑名单
    if bool(data_title_blacklist):
        tb1 = table_title_blacklist
        for a in (data_title_blacklist): tb1.add_row([a['index'],a['name'],a['title'],a['email'],timeStamp(int(a['timestamp'])),a['page']])
        p1(tb1); p1("设置了黑名单关键词，以上{}封邮件不包含在最终列表中。\n\n".format(len(data_title_blacklist)))

    # 白名单
    if bool(data_title_whitelist):
        tb2 = table_title_whitelist
        for a in (data_title_whitelist): tb2.add_row([a['index'],a['name'],a['title'],a['email'],timeStamp(int(a['timestamp'])),a['page']])
        p1(tb2); p1("设置了白名单关键词，以上{}封邮件不包含在最终列表中。\n\n".format(len(data_title_whitelist)))

    # 最终列表
    if bool(data_email_titlelist):
        tb = table_email_titlelist
        for a in (data_email_titlelist): tb.add_row([a['index'],a['name'],a['title'],a['email'],timeStamp(int(a['timestamp'])),a['page']])
        p1(tb);p1("最终列表共有{}封邮件。\n".format(len(data_email_titlelist)))


# 打印附件列表
def print_files_table():

    # 没有附件的邮件列表
    if bool(data_email_nofilelist):
        tb1 = table_email_nofilelist
        for a in (data_email_nofilelist): tb1.add_row([a['index'],a['name'],a['title'],a['email'],timeStamp(int(a['timestamp'])),a['page']])
        p1(tb1); p1("有{}封邮件没有附件的主题，已标记为星标邮件。\n\n".format(len(data_email_nofilelist)))

    # 附件列表
    if bool(data_email_fileslist):
        tb = table_email_fileslist
        for a in (data_email_fileslist): tb.add_row([a['ti'],a['page'],a['tn'],a['filename'],a['tt'],a['email'],a['filebyte'],a['viewmode'],timeStamp(int(a['timestamp'])),a['index']])
        p1(tb);p1("当前的附件列表，已统计{}个文件。\n".format(len(data_email_fileslist)))


#...............................................................................
# Ended Event
#...............................................................................

def download_end():
  if can_print_files_table: print_files_table()
  if is_export_filelist_csv: ptable_to_csv(table_email_fileslist, DOWNLOAD_FOLDER+ r"_导出附件列表_" + now + r".csv")
  if is_ended_jump_home: get_url("https://mail.qq.com/")
  print_download_end()

#...............................................................................
#  Main
#...............................................................................

if __name__ == '__main__':

    now = time.strftime("%Y%m%d_%H%M%S",time.localtime(time.time()))

    get_url("https://mail.qq.com/")
    ActionChains(chrome).send_keys(Keys.ESCAPE).perform()

    os.system('cls')
    os.system('')

    # 检查是否已经登陆
    if not test_id_exists("login_frame") and test_sid_exists(): auto_login()

    print(f'sid: { chrome.current_url.split("sid=")[1].split("&")[0] }')

    #获取文件夹列表
    if not bool(data_folders_list): get_folder_list()
    if not bool(config['TOKEN']["sid"]): update_token()

    # 是否更改邮箱每页显示数量、邮件列表视图
    if can_setting_mail: setting_email()

    # 进入文件夹，获取邮件列表
    if just_login_mail: 
      p1("\nsid: \n{}".format(config['TOKEN']["sid"])); 
      p1("\n如果要继续打开文件夹")
      os.system("PAUSE")
      os.system('cls')

    try: open_next_page()
    except: chrome.refresh();open_next_page();
    
    data_email_titlelist = data_email_titlelist[::-1] if can_reverse_list else data_email_titlelist
    
    # 打开邮件，获取附件列表
    if just_print_mail:
      p1("如果要继续下载附件")
      os.system("PAUSE")
      os.system('cls')

    open_email()

    if is_export_titlelist_csv: ptable_to_csv(table_email_titlelist, DOWNLOAD_FOLDER+ r"_导出邮件列表" + now + r".csv")
    
p1("运行结束。")
